Суть алгоритма:
Т.к. массив отсортирован по времени прибытия, то время прибытия i элемента всегда больше или равно времени
прибытия i-1 элемента.
Для начала я говорю пусть 0 элемент идеальный и начинаю проверять остальные элементы относительно него.
Если i элемент лучше i-1, то я удаляю i-1 элемент и теперь на его месте будет новый элемент.
При этом перепроверять элемент на позиции i-1 с i-2 не нужно, это исходит из того, что время отправления
i-1 будет больше чем у i-2, а его время прибытия будет больше чем у старого элемента на позиции i-1(исходит
из того, почему вообще был удалён элемент i-1), значит и больше чем у i-2, значит их сравнивать не нужно.
Не исключение и элемент на 1 позиции, ведь при сравнении его с 0 и удалении 0, он станет на 0 позиции
идеальным и сравнивать его ни с чем не надо. Если же я удаляю i элемент, i+1 станет на его место и его надо
будет сравнить с i-1 элементом. В случае когда я не удаляю ни один элемент, я просто сравниваю дальше i+1 с
i.
В конце проверяется особый случай, ведь вдруг 0 элемент не идеальный, а последний элемент на самом деле
лучше 0 и других. Для этого и нужен последний цикл while.

Реализация алгоритма по данным из input.txt:
Для начала отсортируем данные по времени прибытия. 
0)Grotty 17:00 00:10
1)Posh 23:30 00:10
2)Posh 23:31 00:11
3)Grotty 23:29 00:11
4)Posh 00:10 00:20
5)Grotty 23:45 00:20
6)Posh 00:15 00:21
7)Grotty 00:40 01:20
8)Posh 10:00 11:00
9)Grotty 10:00 11:00
10)Grotty 12:00 12:30
11)Posh 12:00 12:40
12)Grotty 14:30 14:49
13)Posh 14:30 14:50
14)Posh 14:29 14:51
15)Posh 14:32 15:00
16)Posh 16:00 15:30
17)Grotty 16:00 17:10
18)Grotty 23:00 23:40
19)Posh 23:01 23:40
20)Grotty 23:49 23:59
21)Posh 23:50 23:59

Затем удалим все случаи, где автобус едет больше часа.
0)Posh 23:30 00:10
1)Posh 23:31 00:11
2)Grotty 23:29 00:11
3)Posh 00:10 00:20
4)Grotty 23:45 00:20
5)Posh 00:15 00:21
6)Grotty 00:40 01:20
7)Posh 10:00 11:00
8)Grotty 10:00 11:00
9)Grotty 12:00 12:30
10)Posh 12:00 12:40
11)Grotty 14:30 14:49
12)Posh 14:30 14:50
13)Posh 14:29 14:51
14)Posh 14:32 15:00
15)Grotty 23:00 23:40
16)Posh 23:01 23:40
17)Grotty 23:49 23:59
18)Posh 23:50 23:59

Делается проверка, не пустой ли наш массив. Если пустой, алгоритм заканчивается. Если массив состоит из 1 элемента, то алгоритм тоже заканчивается.

Далее запускается цикл while, который будет идти начиная с 1 позиции до тех пор, пока у текущего элемента время прибытия меньше 01:00. В данном случае мы учитываем, что время отправки может быть до 00:00.
0)Posh 23:30 00:10
1)Posh 23:31 00:11
2)Posh 00:10 00:20
3)Posh 00:15 00:21
4)Grotty 00:40 01:20
5)Posh 10:00 11:00
6)Grotty 10:00 11:00
7)Grotty 12:00 12:30
8)Posh 12:00 12:40
9)Grotty 14:30 14:49
10)Posh 14:30 14:50
11)Posh 14:29 14:51
12)Posh 14:32 15:00
13)Grotty 23:00 23:40
14)Posh 23:01 23:40
15)Grotty 23:49 23:59
16)Posh 23:50 23:59

После цикла while мы останавливаемся на 4 позиции. Начинается цикл for.
0)Posh 23:30 00:10
1)Posh 23:31 00:11
2)Posh 00:10 00:20
3)Posh 00:15 00:21
4)Grotty 00:40 01:20
5)Posh 10:00 11:00
6)Grotty 12:00 12:30
7)Grotty 14:30 14:49
8)Posh 14:32 15:00
9)Grotty 23:00 23:40
10)Posh 23:50 23:59

В самом конце начинается цикл while, цель которого проверка особого случая, который здесь присутствует.
Этот случай заключается в том, что если у нашего нулевого элемента начало поездки до 00:00, а у последнего
элемента после 23:00, то мы должны проверять, подходит ли наши нулевой элемент и последующие элементы, до
того момента, пока мы либо не встретим элемент у которого время прибытия позже 01:00 либо мы не будем 
удалять элемент на 0 позиции.
0)Posh 00:10 00:20
1)Posh 00:15 00:21
2)Grotty 00:40 01:20
3)Posh 10:00 11:00
4)Grotty 12:00 12:30
5)Grotty 14:30 14:49
6)Posh 14:32 15:00
7)Posh 23:01 23:40
8)Posh 23:50 23:59

В output.txt будет ответ, который был получен программой и он совпадает с ответом полученным в ходе
вышеперечисленных рассуждений.